JVM生命周期
https://blog.csdn.net/u013541140/article/details/97375248
加载 - 链接（验证，准备，解析）- 初始化 - 使用 -卸载

注意：为了支持java语言的动态绑定（运行时绑定），解析在某种情况下可以是在初始化之后的


加载：查找并加载类的二进制数据
具体流程：
（1）通过类的全限定名来获取类的二进制流。
（2）将二进制流代表的静态存储结构转换成方法区的运行时数据结构。
（3）在内存中（堆）创建一个代表这个类的java.lang.Class对象，以此作为方法区中这个类的各个数据的访问入口。

验证：验证字节码文件是否符合JVM的规范

准备：静态变量分配内存，并赋予初始值。如boolean false,int 0（final修饰的常量直接赋值）

解析：静态符号（ 静态方法）引用替换成直接引用（指向方法区（数据所存内存的指针或者句柄）的内存地址），也叫作静态链接
还有动态链接哦

初始化：真正赋值（静态变量初始化，指向静态代码块）


类加载器
引导类加载器 ：加载jdk\jre\bin目录下的核心jar包
扩展类加载器：加载 jdk\jre\bin\ext 目录下的jar包
应用程序类加载器:加载java.class.path下的class文件（自己写的应用程序）

问题：为什么appclassloader也加载 lib和lib\ext下的核心类库
原因：虽然它打印了，但是并没有加载（双亲委派模式） TestClassLoader

什么是双亲委派机制？
答：当一个类加载器收到加载一个类请求时，先请求父类加载器加载此类，一直向上委托，parent为空则使用引导类加载器。引导类加载不了就向下委托。
直到可以加载为止，或者找不到报错。具体实现是在ClassLoader的loadClass方法

问：为什么要设计双亲委派机制？
答：1、沙箱安全机制:jdk的类不会被覆盖，核心api的库不会被篡改
    2、避免类的重复加载，保证被加载类的唯一性


自定义类加载器
1、继承ClassLoder
2、实现其中的findClass（是一个空实现，重写它），
具体是根据路径到磁盘上读取类，然后加载到内存中（defineClass方法）

默认为系统类加载器（appClassLoder）

如何打破双亲委派机制？
因为双亲委派机制的实现是classLoader的loadClass方法,继承并重写它即可
